# 01背包问题


## 一、问题  


有 `N` 件物品和一个容量为 `V` 的背包。  
第 `i` 件物品的费用是 `c[i]`，价值是 `w[i]`。  
求解将哪些物品装入背包可使价值总和最大。


练习 OJ：https://www.luogu.com.cn/problem/P2871  



## 二、基本思路


最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。  


用子问题定义状态： 即 `f[i][v]` 表示前 `i` 件物品恰放入一个容量为 `v` 的背包可以获得的最大价值。  


只有选择或者不选择，所以状态转移方程如下：


```
f[i][v] = max{f[i-1][v], f[i-1][v-c[i]] + w[i]}
```


解释如下：  


左半部：`f[i-1][v]`。
代表不选择第 `i` 件物品。  
此时子状态的体积不变，为 `f[i-1][v]`。
当前状态的总价值等价与子状态的价值。  


右半部：`f[i-1][v-c[i]] + w[i]`。
代表选择第 `i` 件物品。  
此时子状态需要减去当前物品的体积，为`f[i-1][v-c[i]]`。
当前状态的总价值为子状态的价值加上当前物品的总价值。



时间复杂度：`O(N V)`  
空间复杂度：`O(N V)`



伪代码如下：  


```
for (int i = 0; i < n; i++) {
    for (int v = 0; v < V; v++) {
        if(v < c[i]) {
            f[i][v] = f[i-1][v];
        } else {
            f[i][v]=max(f[i-1][v], f[i-1][v - c[i]] + w[i]);
        }
    }
}
```


## 三、空间优化  


仔细看下上一小节的伪代码，可以发现，第 `i` 个物品的状态只与 第 `i-1` 个物品的状态有关。  


所以，最直接的思路是使用滚动数组来优化空间。  


如果再深入的分析一下这个状态转移方程，会发现也可以使用一个数组来实现状态转移。  


状态：`f[i][v] = max{f[i-1][v], f[i-1][v-c[i]] + w[i]}`  


可以发现，对于第 `i` 个物品的状态 `f[i][v]` 只与状态 `f[i-1][v]` 和 `f[i-1][v-c[i]]` 有关。  
换句话说就是，至于小于等于体积 v 的状态有关，大于体积　V 的状态与当前状态无关。  


那我们的循环从大体积到小体积循环，就可以做到不影响逻辑的前提下，复用同一个数组。  


伪代码：  


```
for (int i = 0; i < n; i++) {
    for (int v = V; v >= c[i]; v--) {
        f[v]=max(f[v], f[v - c[i]] + w[i]);
    }
}
```


## 四、总结  


01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。  


故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。



## 五、参考资料  


-）背包九讲 第一讲 01背包问题： https://www.kancloud.cn/kancloud/pack/70125  
-）	OI Wiki 背包 DP： https://oi-wiki.org/dp/knapsack/#0-1



